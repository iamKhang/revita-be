@startuml take-number-sequence

actor "Patient" as Patient
actor "Counter Staff" as Staff

boundary "Kiosk Screen" as KioskUI
boundary "Counter Screen" as CounterUI
boundary "Waiting Room Screen" as WaitingUI

control "TakeNumberController" as Controller
control "TakeNumberService" as Service
control "WebSocketService" as WS
entity "PatientProfile" as PatientProfile
entity "Appointment" as Appointment
entity "Counter" as Counter

Patient -> KioskUI: Scan profile code/\nappointment code or\nmanual entry
activate KioskUI

KioskUI -> Controller: POST /take-number/take\n(TakeNumberDto)
activate Controller

Controller -> Service: takeNumber(dto)
activate Service

alt Has patientProfileCode
    Service -> PatientProfile: findFirst(where:\n{profileCode})
    activate PatientProfile
    PatientProfile --> Service: PatientProfile
    deactivate PatientProfile
    Service -> Service: calculateAge(dateOfBirth)
    Service -> Service: hasAppointment = false
    
else Has appointmentCode
    Service -> Appointment: findFirst(where:\n{appointmentCode})
    activate Appointment
    Appointment --> Service: Appointment + PatientProfile
    deactivate Appointment
    Service -> Service: calculateAge(dateOfBirth)
    Service -> Service: hasAppointment = true
    Service -> Service: appointmentDetails = {...}
    
else Manual entry
    Service -> Service: validatePatientName()
    Service -> Service: Create temporary patientInfo\ngender = UNKNOWN\nage = calculateAge(birthYear)
end

Service -> Service: Determine isPregnant, isDisabled

alt Has appointment
    Service -> Service: calculateIsOnTime(appointment)\nÂ±20 minutes from startTime
else No appointment
    Service -> Service: isOnTime = false
end

Service -> Counter: findMany(where:\n{isActive: true})
activate Counter
Counter --> Service: Counter[]
deactivate Counter

Service -> Service: selectBestCounter()

loop For each counter
    Service -> Service: getQueueLength(counterId)
end

Service -> Service: Sort by queueLength\nSelect counter with least people

Service -> Service: calculateQueuePriority(\nage, isDisabled, isPregnant,\nhasAppointment, sequence,\ncallCount, status)

Service -> Service: generateSequence(counterId)

Service -> Service: Create ticketId (UUID)\nCreate queueNumber\nCreate QueueTicket object\nstatus = WAITING\ncallCount = 0

Service -> Service: getCurrentQueue(counterId)

Service -> Service: addTicketToStream(ticket)

Service -> Service: pushToCounterQueue(counterId, ticket)

Service -> Service: getCurrentQueue(counterId)

Service -> Service: Compare oldQueue vs newQueue\nFind movedPatients

Service -> WS: notifyNewTicket(counterId, ticket)
activate WS
WS -> CounterUI: Notify new ticket
WS -> WaitingUI: Update waiting list
deactivate WS

Service -> WS: notifyNewTicketQueueChanges(\ncounterId, oldQueue, ticket)
activate WS
WS -> CounterUI: Update queue position
WS -> WaitingUI: Update queue order
deactivate WS

Service -> Service: enrichTicketForFrontend(ticket)\nAdd flags: isOnTime,\nisElderly, isChild

Service --> Controller: TakeNumberResult\n(success, ticket, patientInfo)
deactivate Service

Controller --> KioskUI: 200 OK\n(ticket info)
deactivate Controller

KioskUI --> Patient: Display:\n- Queue number: <queueNumber>\n- Counter: <counterName>\n- Ticket time
deactivate KioskUI

Staff -> CounterUI: Observe new ticket
Patient -> WaitingUI: Observe queue number\non waiting screen

CounterUI --> Staff: Display new\npatient information

WaitingUI --> Patient: Display list of\npatients waiting to be called

@enduml
