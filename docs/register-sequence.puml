@startuml Register Sequence Diagram
!theme plain

actor "User" as U
boundary "Frontend" as F
control "RegisterController" as C
control "RegisterService" as R
entity "EmailService" as E
entity "SmsService" as S
entity "Account" as A
entity "Patient" as P
entity "Redis" as RED

U -> F: Enter phone or email
F -> C: POST /register/step1
note right: RegisterDto
C -> C: validateRegisterDto(dto)
C -> R: registerStep1(registerDto)
R -> A: checkPhoneOrEmailExists(phoneOrEmail)
A -> A: prisma.auth.findFirst()
A --> R: existingAuth\n(account if exists, null otherwise)

alt Phone/email not exists
  R -> R: generateOTP()
  R -> R: generateSessionId()
  R -> RED: saveSessionData(sessionId, sessionData)
  RED -> RED: redis.setex()
  RED --> R: success\n(session saved with 15min expiry)
  
  R -> RED: saveOTP(phoneOrEmail, otp, 300)
  RED -> RED: redis.setex()
  RED --> R: success\n(OTP saved with 5min expiry)
  
  alt Has phone
    R -> S: sendSMS(phone, otp)
    S -> S: smsProvider.send()
    S --> R: result\n(SMS sent confirmation)
    
  else Has email
    R -> E: sendEmail(email, otp)
    E -> E: emailProvider.send()
    E --> R: result\n(email sent confirmation)
  end
  
  R --> C: response\n(sessionId and OTP sent message)
  C --> F: response\n(session data)
  F --> U: Display OTP sent message
  
else Phone/email exists
  R --> C: throw ConflictException()
  C --> F: error\n(already registered message)
  F --> U: Display already registered message
end

U -> F: Enter OTP code
F -> C: POST /register/verify-otp
note right: VerifyOtpDto
C -> C: validateVerifyDto(dto)
C -> R: verifyOtp(verifyDto)
R -> RED: getSessionData(sessionId)
RED -> RED: redis.get()
RED --> R: sessionData\n(session info if valid, null if expired)
R -> RED: getOTP(phoneOrEmail)
RED -> RED: redis.get()
RED --> R: savedOtp\n(OTP code if valid, null if expired)

alt OTP valid
  R -> RED: updateSessionVerified(sessionId)
  RED -> RED: redis.setex()
  RED --> R: success\n(session marked as verified)
  R -> RED: deleteOTP(phoneOrEmail)
  RED -> RED: redis.del()
  RED --> R: success\n(OTP deleted after use)
  R --> C: response\n(verification success confirmation)
  C --> F: response\n(verified session data)
  F --> U: Display verification success, proceed to step 3
  
else OTP invalid
  R --> C: throw BadRequestException()
  C --> F: error\n(OTP incorrect or expired message)
  F --> U: Display OTP incorrect message
end

U -> F: Enter personal info and password
F -> C: POST /register/complete
note right: CompleteRegistrationDto
C -> C: validateCompleteDto(dto)
C -> R: completeRegistration(completeDto)
R -> RED: getSessionData(sessionId)
RED -> RED: redis.get()
RED --> R: sessionData\n(verified session data)

alt Session valid and verified
  R -> A: checkCitizenIdExists(citizenId)
  A -> A: prisma.auth.findFirst()
  A --> R: existingAuth\n(account with citizenId if exists)
  
  alt CitizenId not exists
    R -> R: hashPassword(password)
    R -> R: beginTransaction()
    
    R -> A: createAccountRecord(accountData)
    A -> A: prisma.auth.create()
    A --> R: auth\n(new account with encrypted password)
    
    R -> P: createPatientRecord(patientData)
    P -> P: prisma.patient.create()
    P --> R: patient\n(new patient linked to account)
    
    R -> RED: deleteSession(sessionId)
    RED -> RED: redis.del()
    RED --> R: success\n(session cleaned up)
    
    R -> E: sendWelcomeNotification(email)
    E -> E: emailProvider.send()
    E --> R: result\n(welcome email sent)
    
    R -> R: commitTransaction()
    R --> C: response\n(registration complete with account info)
    C --> F: response\n(success message)
    F --> U: Display registration success
    
  else CitizenId exists
    R --> C: throw ConflictException()
    C --> F: error\n(citizen ID already registered message)
    F --> U: Display ID already registered message
  end
  
else Session invalid
  R --> C: throw BadRequestException()
  C --> F: error\n(session expired or invalid message)
  F --> U: Display session invalid message
end

@enduml